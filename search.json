[{"path":"https://stat545ubc-2023.github.io/Rutils/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Gian Carlo Diluvi Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/articles/logexp.html","id":"log1p","dir":"Articles","previous_headings":"","what":"Log1p","title":"log1p and expm1 operations","text":"Suppose \\(x=10^{-20}\\). value small large enough represented computer. However, since floating-point arithmetic numbers able represent computer evenly spaced, number \\(1+x=1+10^{-20}\\) represented \\(1\\). Hence naive computation \\(\\log(1+x)\\) return \\(\\log(1)=0\\). Log1p trick refers fact , small \\(x\\), \\(\\log(1+x)\\approx x\\). Rutils::Log1p checks \\(x\\) small \\(1+x\\) computed safely, approximates \\(\\log(1+x)\\) \\(x\\). See example : values \\(x<10^{-16}\\), naive computation returns \\(0\\) Log1p returns \\(x>0\\). Also note Log1p vectorized.","code":"my_x <- 10^(-(10:20)) print(Log1p(my_x)) #>  [1] 1e-10 1e-11 1e-12 1e-13 1e-14 1e-15 1e-16 1e-17 1e-18 1e-19 1e-20 print(log(1+my_x)) #>  [1] 1.000000e-10 1.000000e-11 1.000089e-12 9.992007e-14 9.992007e-15 #>  [6] 1.110223e-15 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 #> [11] 0.000000e+00"},{"path":"https://stat545ubc-2023.github.io/Rutils/articles/logexp.html","id":"expm1","dir":"Articles","previous_headings":"","what":"Expm1","title":"log1p and expm1 operations","text":"suppose \\(x=10^{-20}\\). operation \\(\\exp(x)\\) return \\(0\\) since computer able represent small number. using Taylor’s expansion, \\(\\exp(x)\\approx 1+x\\). , can approximate \\(\\exp(x)-1\\) \\(x\\) sufficiently small \\(x\\), Rutils::Expm1 checks automatically. See example : , \\(x<10^{-16}\\) naive computation returns 0 Expm1 returns \\(x>0\\). function Expm1 also vectorized.","code":"my_x <- 10^(-(10:20)) print(Expm1(my_x)) #>  [1] 1.000000e-10 1.000000e-11 1.000089e-12 9.992007e-14 9.992007e-15 #>  [6] 1.110223e-15 1.000000e-16 1.000000e-17 1.000000e-18 1.000000e-19 #> [11] 1.000000e-20 print(exp(my_x)-1) #>  [1] 1.000000e-10 1.000000e-11 1.000089e-12 9.992007e-14 9.992007e-15 #>  [6] 1.110223e-15 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 #> [11] 0.000000e+00"},{"path":"https://stat545ubc-2023.github.io/Rutils/articles/logsumexp.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"logsumexp trick","text":"First example using LogSumExp trick doesn’t actually help, just verify obtain correct answer. Now example trick actually helps: naive computation doesn’t work \\(\\exp(-10^{5})\\) \\(\\exp(-10^{12})\\) smaller computer precision can represent, rounded 0. Added ’re still 0 \\(\\log 0\\) results \\(-\\infty\\). LogSumExp trick avoids since \\(x^\\star = -10^{5}\\) sum terms become \\(\\exp(-10^{5}+10^{5})=1\\) \\(\\exp(-10^{12}+10^{5})\\) still represented 0. log sum exps now 0, add \\(x^\\star=-10^{5}\\). large negative \\(-\\infty\\). Now realistic example trick also helps. Suppose want evaluate log pdf mixture model 10 elements mixture: \\(\\log p(x) = \\log(p_1(x)+\\cdots+p_{10}(x))\\), \\(p_n(x)\\) pdf \\(n\\) th mixture element, case N\\((10n,0.1^2)\\) distribution. Note \\(p_n(x) = \\exp\\log p_n(x)\\), allows us cast problem LogSumExp trick format. set \\(x=54\\) show naive method produces underflow LogSumExp trick .","code":"library(Rutils) my_x = c(1:10) trick <- logsumexp(my_x) direct <- log(sum(exp(my_x))) print(paste(\"The correct answer is \", direct, \" and the LogSumExp trick yields \", trick)) #> [1] \"The correct answer is  10.4586297444267  and the LogSumExp trick yields  10.4586297444267\" my_x = c(-1e5,-1e12) trick <- logsumexp(my_x) direct <- log(sum(exp(my_x))) print(paste(\"The correct answer is \", trick, \" but the naive method yields \", direct)) #> [1] \"The correct answer is  -1e+05  but the naive method yields  -Inf\" # setup means <- 10*(1:10) sd <- 0.1 test_x <- 54  # calculate log pdfs lprbs <- rep(0,10) for(n in 1:10) lprbs[n] <- dnorm(test_x, mean = means[n], sd = sd, log = TRUE)  # estimate log pdf of mixture model trick <- logsumexp(lprbs) direct <- log(sum(exp(lprbs))) print(paste(\"The LogSumExp trick yields \", trick, \" but the naive method yields \", direct)) #> [1] \"The LogSumExp trick yields  -798.616353440211  but the naive method yields  -Inf\""},{"path":"https://stat545ubc-2023.github.io/Rutils/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gian Carlo Diluvi. Author, maintainer.","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Diluvi G (2023). Rutils: Utility Functions Numerically-Stable Machine Learning R. R package version 0.1.0, https://stat545ubc-2023.github.io/Rutils/.","code":"@Manual{,   title = {Rutils: Utility Functions For Numerically-Stable Machine Learning In R},   author = {Gian Carlo Diluvi},   year = {2023},   note = {R package version 0.1.0},   url = {https://stat545ubc-2023.github.io/Rutils/}, }"},{"path":"https://stat545ubc-2023.github.io/Rutils/index.html","id":"rutils","dir":"","previous_headings":"","what":"Utility Functions For Numerically-Stable Machine Learning In R ","title":"Utility Functions For Numerically-Stable Machine Learning In R ","text":"Rutils allows safely compute operations prone numerical overflow R.","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Utility Functions For Numerically-Stable Machine Learning In R ","text":"can install development version Rutils GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"stat545ubc-2023/Rutils\")"},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Expm1.html","id":null,"dir":"Reference","previous_headings":"","what":"Expm1 — Expm1","title":"Expm1 — Expm1","text":"Compute exp(x)-1 numerically-stable fashion","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Expm1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expm1 — Expm1","text":"","code":"Expm1(x)"},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Expm1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expm1 — Expm1","text":"x numeric","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Expm1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expm1 — Expm1","text":"numeric, size x","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Expm1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expm1 — Expm1","text":"","code":"Expm1(1e-20) #> [1] 1e-20 # compare to naive approach: exp(1e-20)-1 #> [1] 0"},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"log1p — Log1p","title":"log1p — Log1p","text":"Compute log(1+x) numerically-stable fashion","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"log1p — Log1p","text":"","code":"Log1p(x)"},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"log1p — Log1p","text":"x numeric","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"log1p — Log1p","text":"numeric, size x","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/Log1p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"log1p — Log1p","text":"","code":"Log1p(1e-20) #> [1] 1e-20 # compare to naive approach: log(1+1e-20) #> [1] 0"},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/logsumexp.html","id":null,"dir":"Reference","previous_headings":"","what":"LogSumExp — logsumexp","title":"LogSumExp — logsumexp","text":"Compute log(sum(exp(x))) numerically-stable fashion","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/logsumexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogSumExp — logsumexp","text":"","code":"logsumexp(x)"},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/logsumexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogSumExp — logsumexp","text":"x numeric, usually vector","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/logsumexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LogSumExp — logsumexp","text":"numeric, single number","code":""},{"path":"https://stat545ubc-2023.github.io/Rutils/reference/logsumexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogSumExp — logsumexp","text":"","code":"logsumexp(c(-1e5,-1e12)) #> [1] -1e+05 # compare to log(sum(exp(c(-1e5,-1e12)))) log(sum(exp(c(-1e5,-1e12)))) #> [1] -Inf"}]
